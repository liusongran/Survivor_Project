#include <task.h>
#include <apps.h>

#define TASK_PRI    0

#if ENABLE_PRF
__nv uint8_t full_run_started = 0;
__nv uint8_t first_run = 1;
#endif

#ifndef RST_TIME
#define RST_TIME 25000
#endif

extern uint32_t lowestaddr;
extern uint32_t highestaddr;


#define NIL 0 // like NULL, but for indexes, not real pointers

#define DICT_SIZE         64
#define BLOCK_SIZE         32

#define NUM_LETTERS_IN_SAMPLE        2
#define LETTER_MASK             0x001F
#define LETTER_SIZE_BITS             8
#define NUM_LETTERS (LETTER_MASK + 1)


typedef uint16_t index_t;
typedef uint16_t letter_t;
typedef uint16_t sample_t;

// NOTE: can't use pointers, since need to ChSync, etc
typedef struct _node_t {
    letter_t letter; // 'letter' of the alphabet
    index_t sibling; // this node is a member of the parent's children list
    index_t child;   // link-list of children
} node_t;

// Tasks.
TASK(init);//0
TASK(init_dict);
TASK(sample);
TASK(measure_temp);
TASK(letterize);
TASK(compress);
TASK(find_sibling);
TASK(add_node);
//TASK(add_insert);
TASK(append_compressed);
TASK(done);  //10


//redVerSum 0
//redBakCksumSum 340
//Solution [ 9. 11. 10. 13.  1.  8.  2.  4.  3.  7. 12.  5. 16.  6. 14. 15.]

//# TASK(init) [R-or-RW() || RW-or-W-or-WR(2,3,4,5,6,8,12,16)]
//# TASK(sample) [R-or-RW(3,4) || RW-or-W-or-WR(3,4,7)]
//# TASK(letterize) [R-or-RW(3,5,6,7,12,14,16) || RW-or-W-or-WR(1,2,5,6,7,8,9,10,11,12,13,14,16)]
//# TASK(done) [R-or-RW() || RW-or-W-or-WR()]

__shared(
    index_t _v_sibling;                     // -[9]:2                       --2
    index_t _v_parent;                      // -[11]:2                      --4
    index_t _v_child;                       // -[10]:2                      --6
    node_t _v_parent_node;                  // -[13]:6                      --12
    node_t _v_compressed_data[BLOCK_SIZE];  // -[1]:6*BLOCK_SIZE=6*32=192   --204
    index_t _v_sample_count;                // -[8]:2                       --206
    letter_t _v_letter;                     // -[2]:2                       --208
    sample_t _v_prev_sample;                // -[4]:2                       --210
    unsigned _v_letter_idx;                 // -[3]:1                       --211
    sample_t _v_sample;                     // -[7]:2                       --213
    index_t _v_parent_next;                 // -[12]:2                      --215
    index_t _v_out_len;                     // -[5]:2                       --217
    node_t _v_dict[DICT_SIZE];              // -[16]:6*DICT_SIZE=6*64=384   --601
    index_t _v_node_count;                  // -[6]:2                       --603
    node_t _v_sibling_node;                 // -[14]:6                      --609
    index_t _v_symbol;                      // -[15]:2                      --611
)

//redVerSum 11872
//redBakCksumSum 984
//Solution [ 3. 16. 14. 15.  1. 12.  6.  8.  2.  9. 11.  5. 13. 10.  4.  7.]
//__shared(
//    unsigned _v_letter_idx;                 // -[3]:1
//    node_t _v_dict[DICT_SIZE];              // -[16]:6*DICT_SIZE=6*64=384 --611
//    node_t _v_sibling_node;                 // -[14]:6
//    index_t _v_symbol;                      // -[15]:2 --227
//    node_t _v_compressed_data[BLOCK_SIZE];  // -[1]:6*BLOCK_SIZE=6*32=192
//    index_t _v_parent_next;                 // -[12]:2
//    index_t _v_node_count;                  // -[6]:2
//    index_t _v_sample_count;                // -[8]:2
//    letter_t _v_letter;                     // -[2]:2
//    index_t _v_sibling;                     // -[9]:2
//    index_t _v_parent;                      // -[11]:2
//    index_t _v_out_len;                     // -[5]:2 --199
//    node_t _v_parent_node;                  // -[13]:6
//    index_t _v_child;                       // -[10]:2
//    sample_t _v_prev_sample;                // -[4]:2
//    sample_t _v_sample;                     // -[7]:2 --203
//)


static sample_t acquire_sample(letter_t prev_sample){
    letter_t sample = (prev_sample + 1) & 0x03;
    volatile uint32_t tempUsed = sample;
    tempUsed = tempUsed*tempUsed;
    tempUsed = sqrt(tempUsed);
    return sample;
}


TASK(init)//0
{
    __SET(_v_parent_next) = 0;
    __SET(_v_out_len) = 0;
    __SET(_v_letter) = 0;
    __SET(_v_prev_sample) = 0;
    __SET(_v_letter_idx) = 0;
    __SET(_v_sample_count) = 1;

    uint16_t j=__GET(_v_letter);;
    for(j=0;j<NUM_LETTERS;j++){
        //j = __GET(_v_letter);
        __SET(_v_dict[j].letter) = j ;
        __SET(_v_dict[j].sibling) =  NIL;
        __SET(_v_dict[j].child) = NIL;
        __SET(_v_letter)++;
    }
    __SET(_v_node_count) =  NUM_LETTERS;
    NEXT(1);
}

TASK(sample)//1
{
    unsigned next_letter_idx = __GET(_v_letter_idx) + 1;
    sample_t prev_sample;
    prev_sample = __GET(_v_prev_sample);
    

    if (next_letter_idx == NUM_LETTERS_IN_SAMPLE)
        next_letter_idx = 0;

    if (__GET(_v_letter_idx) == 0) {
        __SET(_v_letter_idx) = next_letter_idx;
        sample_t sample = acquire_sample(prev_sample);
        prev_sample = sample;
        __SET(_v_prev_sample) = prev_sample;
        __SET(_v_sample) = sample;
    } else {
        __SET(_v_letter_idx) = next_letter_idx;
    }
    NEXT(2);
}

TASK(letterize)//2
{
    unsigned letter_idx = __GET(_v_letter_idx);
    if (letter_idx == 0)
        letter_idx = NUM_LETTERS_IN_SAMPLE;
    else
        letter_idx--;

    unsigned letter_shift = LETTER_SIZE_BITS * letter_idx;
    letter_t letter = (__GET(_v_sample) & (LETTER_MASK << letter_shift)) >> letter_shift;

    __SET(_v_letter) = letter;
    index_t parent = __GET(_v_parent_next);
    uint16_t __cry;
    uint8_t testFlag=0;
    __cry = __GET(_v_dict[parent].child);
    __SET(_v_sibling) = __cry ;
    __cry = __GET(_v_dict[parent].letter);
    __SET(_v_parent_node.letter) =  __cry;
    __cry = __GET(_v_dict[parent].sibling);
    __SET(_v_parent_node.sibling) = __cry;
    __cry = __GET(_v_dict[parent].child);
    __SET(_v_parent_node.child) = __cry;
    __SET(_v_parent) = parent;
    __cry = __GET(_v_dict[parent].child);
    __SET(_v_child) = __cry;
    __SET(_v_sample_count)++;
    uint8_t tskIdx = 0;
    index_t starting_node_idx;
    index_t next_sibling;
    while(1){
        if (__GET(_v_sibling) != NIL) {
            int i = __GET(_v_sibling);
            uint16_t __cry = __GET(_v_letter);
            if (__GET(_v_dict[i].letter) == __cry ) {
                __cry = __GET(_v_sibling);
                __SET(_v_parent_next) = __cry;
                NEXT(2);
            }else{
                if(__GET(_v_dict[i].sibling) != 0){
                    __cry = __GET(_v_dict[i].sibling);
                    __SET(_v_sibling) = __cry;
                }else{}
                    starting_node_idx = (index_t)__GET(_v_letter);
                    __SET(_v_parent_next) = starting_node_idx;

                    if (__GET(_v_child) == NIL) {
                        //NEXT(3);
                        if (__GET(_v_node_count) == DICT_SIZE) { // wipe the table if full
        while (1);
    }

    index_t child = __GET(_v_node_count);
    uint16_t __cry;
    if (__GET(_v_parent_node.child) == NIL) { // the only child

        int i = __GET(_v_parent);

        __cry = __GET(_v_parent_node.letter);
        __SET(_v_dict[i].letter) = __cry;
        __cry  = __GET(_v_parent_node.sibling);
        __SET(_v_dict[i].sibling) = __cry;
        __cry = child;
        __SET(_v_dict[i].child) = __cry;

    } else { // a sibling
        index_t last_sibling = __GET(_v_sibling);
        __cry = __GET(_v_sibling_node.letter);
        __SET(_v_dict[last_sibling].letter) = __cry;
        __cry = child;
        __SET(_v_dict[last_sibling].sibling) = __cry;
        __cry  = __GET(_v_sibling_node.child);
        __SET(_v_dict[last_sibling].child) = __cry;
    }
    __cry = __GET(_v_letter);
    __SET(_v_dict[child].letter) = __cry;
    __SET(_v_dict[child].sibling) = NIL;
    __SET(_v_dict[child].child) = NIL;
    __cry = __GET(_v_parent);
    __SET(_v_symbol) = __cry;
    __SET(_v_node_count)++;

    //NEXT(5);
    //uint16_t __cry;
    int i = __GET(_v_out_len);
    __cry = __GET(_v_symbol);
    __SET(_v_compressed_data[i].letter) = __cry;
    __SET(_v_out_len)++;

    if ( (__GET(_v_out_len)) == BLOCK_SIZE) {
        NEXT(3);
    } else {
        NEXT(1);
    }
                    } else {
                        
                        while(1){
                            i = __GET(_v_sibling);
                            if(__GET(_v_dict[i].sibling) != NIL){
                                next_sibling = __GET(_v_dict[i].sibling);
                                __SET(_v_sibling) = next_sibling;
                            }else{
                                break;
                            }
                        }
                        __cry = __GET(_v_dict[i].letter);
                        __SET(_v_sibling_node.letter) = __cry;
                        __cry = __GET(_v_dict[i].sibling);
                        __SET(_v_sibling_node.sibling) = __cry;
                        __cry = __GET(_v_dict[i].child);
                        __SET(_v_sibling_node.child) = __cry;
                        //NEXT(3);
                        if (__GET(_v_node_count) == DICT_SIZE) { // wipe the table if full
        while (1);
    }

    index_t child = __GET(_v_node_count);
    uint16_t __cry;
    if (__GET(_v_parent_node.child) == NIL) { // the only child

        int i = __GET(_v_parent);

        __cry = __GET(_v_parent_node.letter);
        __SET(_v_dict[i].letter) = __cry;
        __cry  = __GET(_v_parent_node.sibling);
        __SET(_v_dict[i].sibling) = __cry;
        __cry = child;
        __SET(_v_dict[i].child) = __cry;

    } else { // a sibling
        index_t last_sibling = __GET(_v_sibling);
        __cry = __GET(_v_sibling_node.letter);
        __SET(_v_dict[last_sibling].letter) = __cry;
        __cry = child;
        __SET(_v_dict[last_sibling].sibling) = __cry;
        __cry  = __GET(_v_sibling_node.child);
        __SET(_v_dict[last_sibling].child) = __cry;
    }
    __cry = __GET(_v_letter);
    __SET(_v_dict[child].letter) = __cry;
    __SET(_v_dict[child].sibling) = NIL;
    __SET(_v_dict[child].child) = NIL;
    __cry = __GET(_v_parent);
    __SET(_v_symbol) = __cry;
    __SET(_v_node_count)++;

    //NEXT(5);
    //uint16_t __cry;
    int i = __GET(_v_out_len);
    __cry = __GET(_v_symbol);
    __SET(_v_compressed_data[i].letter) = __cry;
    __SET(_v_out_len)++;

    if ( (__GET(_v_out_len)) == BLOCK_SIZE) {
        NEXT(3);
    } else {
        NEXT(1);
    }

                    }
            }
        }else{
            break;
        }
    }
    starting_node_idx = (index_t)__GET(_v_letter);
    __SET(_v_parent_next) = starting_node_idx;

    if (__GET(_v_child) == NIL) {
        //NEXT(3);
        if (__GET(_v_node_count) == DICT_SIZE) { // wipe the table if full
        while (1);
    }

    index_t child = __GET(_v_node_count);
    uint16_t __cry;
    if (__GET(_v_parent_node.child) == NIL) { // the only child

        int i = __GET(_v_parent);

        __cry = __GET(_v_parent_node.letter);
        __SET(_v_dict[i].letter) = __cry;
        __cry  = __GET(_v_parent_node.sibling);
        __SET(_v_dict[i].sibling) = __cry;
        __cry = child;
        __SET(_v_dict[i].child) = __cry;

    } else { // a sibling
        index_t last_sibling = __GET(_v_sibling);
        __cry = __GET(_v_sibling_node.letter);
        __SET(_v_dict[last_sibling].letter) = __cry;
        __cry = child;
        __SET(_v_dict[last_sibling].sibling) = __cry;
        __cry  = __GET(_v_sibling_node.child);
        __SET(_v_dict[last_sibling].child) = __cry;
    }
    __cry = __GET(_v_letter);
    __SET(_v_dict[child].letter) = __cry;
    __SET(_v_dict[child].sibling) = NIL;
    __SET(_v_dict[child].child) = NIL;
    __cry = __GET(_v_parent);
    __SET(_v_symbol) = __cry;
    __SET(_v_node_count)++;

    //NEXT(5);
    //uint16_t __cry;
    int i = __GET(_v_out_len);
    __cry = __GET(_v_symbol);
    __SET(_v_compressed_data[i].letter) = __cry;
    __SET(_v_out_len)++;

    if ( (__GET(_v_out_len)) == BLOCK_SIZE) {
        NEXT(3);
    } else {
        NEXT(1);
    }
    }
    else {
        
        int i;
                        while(1){
                            i = __GET(_v_sibling);
                            if(__GET(_v_dict[i].sibling) != NIL){
                                next_sibling = __GET(_v_dict[i].sibling);
                                __SET(_v_sibling) = next_sibling;
                            }else{
                                break;
                            }
                        }
                        __cry = __GET(_v_dict[i].letter);
                        __SET(_v_sibling_node.letter) = __cry;
                        __cry = __GET(_v_dict[i].sibling);
                        __SET(_v_sibling_node.sibling) = __cry;
                        __cry = __GET(_v_dict[i].child);
                        __SET(_v_sibling_node.child) = __cry;
                        //NEXT(3);
                        if (__GET(_v_node_count) == DICT_SIZE) { // wipe the table if full
        while (1);
    }

    index_t child = __GET(_v_node_count);
    uint16_t __cry;
    if (__GET(_v_parent_node.child) == NIL) { // the only child

        int i = __GET(_v_parent);

        __cry = __GET(_v_parent_node.letter);
        __SET(_v_dict[i].letter) = __cry;
        __cry  = __GET(_v_parent_node.sibling);
        __SET(_v_dict[i].sibling) = __cry;
        __cry = child;
        __SET(_v_dict[i].child) = __cry;

    } else { // a sibling
        index_t last_sibling = __GET(_v_sibling);
        __cry = __GET(_v_sibling_node.letter);
        __SET(_v_dict[last_sibling].letter) = __cry;
        __cry = child;
        __SET(_v_dict[last_sibling].sibling) = __cry;
        __cry  = __GET(_v_sibling_node.child);
        __SET(_v_dict[last_sibling].child) = __cry;
    }
    __cry = __GET(_v_letter);
    __SET(_v_dict[child].letter) = __cry;
    __SET(_v_dict[child].sibling) = NIL;
    __SET(_v_dict[child].child) = NIL;
    __cry = __GET(_v_parent);
    __SET(_v_symbol) = __cry;
    __SET(_v_node_count)++;

    //NEXT(5);
    //uint16_t __cry;
i = __GET(_v_out_len);
    __cry = __GET(_v_symbol);
    __SET(_v_compressed_data[i].letter) = __cry;
    __SET(_v_out_len)++;

    if ( (__GET(_v_out_len)) == BLOCK_SIZE) {
        NEXT(3);
    } else {
        NEXT(1);
    }
    }
}

/*
TASK(add_node)//3
{
    int i = __GET(_v_sibling);

    if (__GET(_v_dict[i].sibling) != NIL) {
        index_t next_sibling = __GET(_v_dict[i].sibling);
        __SET(_v_sibling) = next_sibling;
        NEXT(3);

    } else { // found last sibling in the list

        uint16_t __cry;

        __cry = __GET(_v_dict[i].letter);
        __SET(_v_sibling_node.letter) = __cry;
        __cry = __GET(_v_dict[i].sibling);
        __SET(_v_sibling_node.sibling) = __cry;
        __cry = __GET(_v_dict[i].child);
        __SET(_v_sibling_node.child) = __cry;

        NEXT(4);
    }
}*/

/*
TASK(add_insert)//3
{
    if (__GET(_v_node_count) == DICT_SIZE) { // wipe the table if full
        while (1);
    }

    index_t child = __GET(_v_node_count);
    uint16_t __cry;
    if (__GET(_v_parent_node.child) == NIL) { // the only child

        int i = __GET(_v_parent);

        __cry = __GET(_v_parent_node.letter);
        __SET(_v_dict[i].letter) = __cry;
        __cry  = __GET(_v_parent_node.sibling);
        __SET(_v_dict[i].sibling) = __cry;
        __cry = child;
        __SET(_v_dict[i].child) = __cry;

    } else { // a sibling
        index_t last_sibling = __GET(_v_sibling);
        __cry = __GET(_v_sibling_node.letter);
        __SET(_v_dict[last_sibling].letter) = __cry;
        __cry = child;
        __SET(_v_dict[last_sibling].sibling) = __cry;
        __cry  = __GET(_v_sibling_node.child);
        __SET(_v_dict[last_sibling].child) = __cry;
    }
    __cry = __GET(_v_letter);
    __SET(_v_dict[child].letter) = __cry;
    __SET(_v_dict[child].sibling) = NIL;
    __SET(_v_dict[child].child) = NIL;
    __cry = __GET(_v_parent);
    __SET(_v_symbol) = __cry;
    __SET(_v_node_count)++;

    //NEXT(5);
    //uint16_t __cry;
    int i = __GET(_v_out_len);
    __cry = __GET(_v_symbol);
    __SET(_v_compressed_data[i].letter) = __cry;
    __SET(_v_out_len)++;

    if ( (__GET(_v_out_len)) == BLOCK_SIZE) {
        NEXT(4);
    } else {
        NEXT(1);
    }
}*/

TASK(done)//4
{
    NEXT(0);

}



void _benchmark_cem_init(void)
{
    __THREAD(0);

    // min:[[204, 602], [208, 212], [0, 608], [0, 0]]
    //    |APP num:1.
    //    |InitSum:0(100us)
    //    |BackupSum:55(100us)
    //    |CksumSum:250(100us)
    //    |UpdateSum:135(100us)
    //    |TaskSum:84(100us), num:90.
    //    |VerifySum:25(100us)
    //    |Total:551(100us)

    // max:[[0, 608], [0, 610], [0, 610], [0, 0]]
    //    |APP num:1.
    //    |InitSum:0(100us)
    //    |BackupSum:55(100us)
    //    |CksumSum:250(100us)
    //    |UpdateSum:136(100us)
    //    |TaskSum:84(100us), num:90.
    //    |VerifySum:25(100us)
    //    |Total:552(100us)

    //TASK_INIT(TASK_PRI,initTask,5,may_war_set_crc[0][0],may_war_set_crc[0][1],TASK_breaking_crc[0]);

    TASK_INIT(TASK_PRI,init,                 204,  602);
    //TASK_INIT(TASK_PRI,init_dict,            0,  1);
    TASK_INIT(TASK_PRI,sample,               208,  212);
    //TASK_INIT(TASK_PRI,measure_temp,         0,  1);
    TASK_INIT(TASK_PRI,letterize,            0,  608);
    //TASK_INIT(TASK_PRI,compress,             0,  1);
    //TASK_INIT(TASK_PRI,find_sibling, 0,  1);
    //TASK_INIT(TASK_PRI,add_node, 0,  1);
    //TASK_INIT(TASK_PRI,add_insert, 0,  1);
    //TASK_INIT(TASK_PRI,append_compressed, 0,  1);
    //TASK_INIT(TASK_PRI,print, 1,may_war_set_cem[10][0],may_war_set_cem[10][1],TASK_breaking_cem[10]);
    TASK_INIT(TASK_PRI,done, 0,  0);

}

